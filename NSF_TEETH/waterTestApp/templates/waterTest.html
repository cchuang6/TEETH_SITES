<!DOCTYPE html>
{% load compress %}
<html lang="en">
	<head>
		<meta charset="utf-8">
		<title>Three.js Water Test</title>
		<style>canvas { width: 100%; height: 100%; }</style>
	
	</head>
	<body>
		<!-- Main THREE includes -->
    {% compress js %}
		<script type="text/javascript" src="/static/js/three.min.71.js" charset="utf-8"></script>
		<script type="text/javascript" src="/static/js/Detector.js" charset="utf-8"></script>
		<script type="text/javascript" src="/static/js/dat.gui.min.js" charset="utf-8"></script>
		<script type="text/javascript" src="/static/js/OrbitAndPanControls.js" charset="utf-8"></script>
    <script type="text/javascript" src="/static/js/jquery-1.8.3.min.js" charset="utf-8"></script>
    {% endcompress %}


		<!-------------------->
		<!-- Shaders 		-->
		<!-------------------->
		<!-- Render texture vertex shader. Does not modify anything. -->
		<script id="vs_rt" type="x-shader/x-vertex">
			varying vec2 vUv;

			void main() 
			{
				vUv = uv;
								
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>


		<!-- Render texture fragment shader. Runs a simulation step. -->
		<script id="fs_rt" type="x-shader/x-fragment">
			uniform sampler2D texture;
			uniform vec2 delta, mousePoint;
			uniform int mouseActive;
			uniform float damping, strength, radius;
			
			varying vec2 vUv;
			const float pi = 3.14159;

			void main() 
			{
				// get current frag value
				vec4 info = texture2D(texture, vUv);
				
				// Draw ripples with mouse
				if(mouseActive >= 1) 
				{
          float m = max(0.0, 1.0 - length(vec2(mousePoint.x, mousePoint.y) - vUv) / radius);
					m = 0.5 -cos(m * pi) * 0.5;
					info.r -= m * strength;
				}

				// Main wave propagation
				vec2 dx = vec2(delta.x, 0.0);
				vec2 dy = vec2(0.0, delta.y);
				float average = (
					texture2D(texture, vUv - dx).r +
					texture2D(texture, vUv - dy).r +
					texture2D(texture, vUv + dx).r +
					texture2D(texture, vUv + dy).r
				) * 0.25;
				info.g += (average - info.r) * 2.0;
				
				// attenuate the velocity a little so waves do not last forever
				info.g *= damping;
				
				// move the vertex along the velocity
				info.r += info.g;
				
				// damp the final value
				info.r *= damping;
								
				// set the new vertex height (VS uses color to determine height)
				gl_FragColor = info;
			}
		</script>


		<!-- Normal map vertex shader. Sends heightmap UV to fragment shader. -->
		<script id="vs_normal" type="x-shader/x-fragment">
			varying vec2 vUv;
			
			void main() 
			{
				vUv = uv;

				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
			}
		</script>
		
		
		<!-- Normal map fragment shader. Outputs to normalMap. -->
		<script id="fs_normal" type="x-shader/x-fragment">
			uniform float height;
			uniform vec2 delta;
			uniform sampler2D texture;
	
			varying vec2 vUv;
	
			void main() {
	
				float val = texture2D( texture, vUv ).r;
	
				float valU = texture2D( texture, vUv + vec2( delta.x, 0.0 ) ).r;
				float valV = texture2D( texture, vUv + vec2( 0.0, delta.y ) ).r;
	
				gl_FragColor = vec4( ( 0.5 * normalize( vec3( val - valU, val - valV, height ) ) + 0.5 ), 1.0 );
	
			}		
		</script>


		<!-- Final pass vertex shader. Sets final mesh deformation from heightmap. 
			Calculates light and eye vectors and sends them to fragment shader. -->
    <!-- water material -->
		<script id="vs_setHeight" type="x-shader/x-vertex">
			uniform sampler2D heightMap;
			uniform float scale;
			uniform vec3 lightPos;
			
			varying vec3 lightVec; 
			varying vec3 eyeVec;
			varying vec2 texCoord;

			void main(void)
			{
				
				texCoord = uv;
				vec4 info = texture2D(heightMap, texCoord);
				
				vec3 newpos = position;
				
				// Multiply new height so we can actually see the difference.
				newpos.z = info.r * scale;
				
				gl_Position = projectionMatrix * modelViewMatrix * vec4( newpos, 1.0 );
				
				vec3 n = normalize(normalMatrix * normal);
				vec3 t = normalize(normalMatrix * vec3(1.0, 0.0, 0.0));
				vec3 b = cross(n, t);
				
				vec3 vVertex = vec3(modelViewMatrix * vec4(newpos, 1.0)).xyz;
				vec3 tmpVec = vec3(modelViewMatrix * vec4(lightPos.x, -lightPos.z, lightPos.y, 1.0)).xyz - vVertex;

				lightVec.x = dot(tmpVec, t);
				lightVec.y = dot(tmpVec, b);
				lightVec.z = dot(tmpVec, n);

				tmpVec = -vVertex;
				eyeVec.x = dot(tmpVec, t);
				eyeVec.y = dot(tmpVec, b);
				eyeVec.z = dot(tmpVec, n);
			}
		</script>


		<!-- Final pass fragment shader. Uses normal map and light/eye positions to determine
			final shaded color. Adds ambient lighting and specular highlights. -->
    <!-- water material -->
		<script id="fs_setColor" type="x-shader/x-fragment">
			uniform sampler2D colorMap;
			uniform sampler2D normalMap;
			uniform float invRadius;
			uniform vec3 ambient;
			uniform vec3 diffuse;
			uniform vec3 specular;
			uniform float alpha;
			uniform float shininess;
			
			varying vec3 lightVec;
			varying vec3 eyeVec;
			varying vec2 texCoord;

			void main (void)
			{
				float distSqr = dot(lightVec, lightVec);
				float att = clamp(1.0 - invRadius * sqrt(distSqr), 0.0, 1.0);
				vec3 lVec = lightVec * inversesqrt(distSqr);
				vec3 vVec = normalize(eyeVec);
				
				vec4 base = texture2D(colorMap, texCoord);
				vec3 bump = normalize( texture2D(normalMap, texCoord).xyz * 2.0 - 1.0);

				vec4 vAmbient = vec4(ambient, alpha) * vec4(ambient, alpha);
				
				float diffuse2 = max( dot(lVec, bump), 0.0 );
				vec4 vDiffuse = vec4(diffuse, alpha) * vec4(diffuse, alpha) * diffuse2;

				float specular2 = pow(clamp(dot(reflect(-lVec, bump), vVec), 0.0, 1.0), shininess );
				vec4 vSpecular = vec4(specular, alpha) * vec4(specular, alpha) * specular2;
				
				gl_FragColor = vec4((( vAmbient*base + vDiffuse*base + vSpecular ) * att).xyz, alpha);
			}
		</script>
						

		<!-------------------->
		<!-- Main Logic		-->
		<!-------------------->
		<script>
			if (!Detector.webgl)
			{
				Detector.addGetWebGLMessage();
			}

			//------------------------------------------
			// Globals
			//------------------------------------------
			var cameraRTT, cameraControls, sceneRTT, scene, renderer;
			var rtTexture, rtTexture2, normalMap;
			var simRes = 256;
			var rtUniforms, mainUniforms, normalUniforms;
			var water, waterMat;
			var mouseDown;
			var gui, guiParams, guiNeedsUpdate, mainFolder, lightFolder, waterColorFolder;
			var normalMat, screenMat;
			var light, lensFlare;
			var animateLight = false;
			var controls, clock;
			
			var renderTargetLinearFloatParams = {
				minFilter:THREE.LinearFilter,
				magFilter:THREE.LinearFilter,
				wrapS:THREE.RenderTargetWrapping,
				wrapT:THREE.RenderTargetWrapping,
				format:THREE.RGBAFormat,
				stencilBuffer:false,
				depthBuffer:false,
				type:THREE.FloatType
			};

    function loadSky(){
        var cubeMap = THREE.ImageUtils.loadTextureCube([
            "/static/img/px.jpg",
            "/static/img/nx.jpg",
            "/static/img/py.jpg",
            "/static/img/ny.jpg",
            "/static/img/pz.jpg",
            "/static/img/nz.jpg",
        ]);
    
        cubeMap.format = THREE.RGBFormat;
        
        // This is for water-material-height-field
        //var cubeMap = reflectionCube;
    
        var cubeShader = THREE.ShaderLib['cube'];
        cubeShader.uniforms['tCube'].value = cubeMap;
    
        var skyBoxMaterial = new THREE.ShaderMaterial({
          fragmentShader: cubeShader.fragmentShader,
          vertexShader: cubeShader.vertexShader,
          uniforms: cubeShader.uniforms,
          depthWrite: false,
          side: THREE.BackSide
        });
    
            var skybox = new THREE.Mesh(
              new THREE.BoxGeometry(100000, 100000, 100000),
              skyBoxMaterial
            );
            
            scene.add(skybox);
      }

			
			//------------------------------------------
			// Main init and loop
			//------------------------------------------
			start();
			update();

			//------------------------------------------
			// Initialization
			//------------------------------------------
			function start(){
        

				scene = new THREE.Scene();
				sceneRTT = new THREE.Scene();
				
				clock = new THREE.Clock();
				
        // RENDERER
        if (Detector.webgl)
            renderer = new THREE.WebGLRenderer( {antialias:true, alpha: true} );
        else{
            Detector.addGetWebGLMessage();
            renderer = new THREE.CanvasRenderer();
        }
        var canvasWidth = window.innerWidth;
        var canvasHeight = window.innerHeight;
				renderer.setSize(canvasWidth, canvasHeight);
				renderer.setClearColor(0x808080);
				renderer.autoClear = false;
				//renderer.shadowMapEnabled = true;

				document.body.appendChild( renderer.domElement );			
				
        //add skybox
        loadSky();

				// add a basic directional light
        // LIGHTS
        var lightRadius = 850.0
				light = new THREE.DirectionalLight(0xffff55, 1);
				light.position.set(850 * Math.sin(Math.PI/4.0), 250, 850 * Math.cos(Math.PI/4.0));
				light.target.position.set(0, 0, 0);
				light.castShadow = true;
				//light.shadowCameraVisible = true;
				scene.add( light );	
										
				// Setup GUI
				setupGUI();
				
				// Setup render-to-texture scene
				setupRTTScene();
				
				// Setup main scene
				setupMainScene();
				
				// Setup mouse event handlers
				setupControls();				

				// controls
				//cameraControls = new THREE.OrbitControls( camera );
			}
			
			
			//------------------------------------------
			// Setup the GUI defaults and functions
			//------------------------------------------
			function setupGUI(){
				guiNeedsUpdate = false;
				guiParams = {
					damping: 0.99,
					strength: 0.075,
					radius: 0.025,
					scale: 3.0,
					alpha: 0.6,
					ambient: "#c5bbae",
					diffuse: "#ffffff",
					specular: "#ffffff",
					shininess: 50,
					height: 0.05,
					lightPosX: Math.sin(Math.PI/4)*850,
					lightPosY: 250.0,
					lightPosZ: Math.cos(Math.PI/4)*850,
					animateLight: false,
					reset: function() {
						rtUniforms.damping.value = this.damping;
						rtUniforms.strength.value = this.strength;
						rtUniforms.radius.value = this.radius;
						mainUniforms.scale.value = this.scale;
						mainUniforms.alpha.value = this.alpha;
						mainUniforms.shininess.value = this.shininess;
						mainUniforms.lightPos.value.x = this.lightPosX;
						mainUniforms.lightPos.value.y = this.lightPosY;
						mainUniforms.lightPos.value.z = this.lightPosZ;
						animateLight = this.animateLight = false;
						this.ambient = "#c5bbae";
						this.diffuse = "#ffffff";
						this.specular = "#ffffff";
						mainUniforms.ambient.value = new THREE.Color(this.ambient);
						mainUniforms.diffuse.value = new THREE.Color(this.diffuse);
						mainUniforms.specular.value = new THREE.Color(this.specular);
						normalUniforms.height.value = this.height;
            clock.stop();
            clock.startTime = 0;
            clock.oldTime = 0;
            clock.elapsedTime = 0;
						guiNeedsUpdate = true;
            
					}
				};
				
				// Setup materials
				setupMats();
							
				gui = new dat.GUI();
				
				mainFolder = gui.addFolder("Main Settings");
				mainFolder.add(rtUniforms.damping, "value", 0.0, 1.0).name("Damping");
				mainFolder.add(rtUniforms.strength, "value", 0.0, 0.1).name("Input Strength");
				mainFolder.add(rtUniforms.radius, "value", 0.0, 0.1).name("Input Radius");
				mainFolder.add(mainUniforms.scale, "value", 0.0, 100.0).name("Simulation Scale");
				mainFolder.open();
				
				lightFolder = gui.addFolder("Light Position");
				lightFolder.add(mainUniforms.lightPos.value, "x").name("X");
				lightFolder.add(mainUniforms.lightPos.value, "y").name("Y");
				lightFolder.add(mainUniforms.lightPos.value, "z").name("Z");
				lightFolder.add(guiParams, "animateLight").name("Animate Light").onChange(function(newValue) { animateLight = newValue; 
          if(newValue)
            clock.start();
          else
            clock.stop();
          guiNeedsUpdate = true; });
				lightFolder.open();
				
				waterColorFolder = gui.addFolder("Water Colors");
				waterColorFolder.addColor(guiParams, "ambient").name("Ambient").onChange(function(colorValue) { mainUniforms.ambient.value = new THREE.Color(colorValue); });
				waterColorFolder.addColor(guiParams, "diffuse").name("Diffuse").onChange(function(colorValue) { mainUniforms.diffuse.value = new THREE.Color(colorValue); });
				waterColorFolder.addColor(guiParams, "specular").name("Specular").onChange(function(colorValue) { mainUniforms.specular.value = new THREE.Color(colorValue); });
				waterColorFolder.add(mainUniforms.alpha, "value", 0.0, 1.0).name("Opacity");
				waterColorFolder.add(mainUniforms.shininess, "value", 0.0, 300.0).name("Shininess");
				waterColorFolder.add(normalUniforms.height, "value", 0.001, 0.1).name("Normal Height");
				waterColorFolder.open();
				
				gui.add(guiParams, "reset").name("Reset to Defaults");
			}
			
			
			//------------------------------------------
			// Setup the render target textures and materials
			//------------------------------------------
			function setupMats(){
				// create buffers
				rtTexture = new THREE.WebGLRenderTarget( simRes, simRes, renderTargetLinearFloatParams );				
				rtTexture2 = new THREE.WebGLRenderTarget( simRes, simRes, renderTargetLinearFloatParams );
				normalMap = new THREE.WebGLRenderTarget( simRes, simRes, renderTargetLinearFloatParams );
				
				var delta = 1.0 / simRes;
				
				// main render-to-texture material
				rtUniforms = {
					texture: { type: "t", value: rtTexture2 },
					delta: { type: "v2", value: new THREE.Vector2( delta, delta ) },
					//mousePoint: { type:"v2", value: new THREE.Vector2(-1, -1) },
          mousePoint: { type:"v2", value: new THREE.Vector2(0, 0) },
					mouseActive: { type:"i", value: 0 },
					damping: { type: "f", value: guiParams.damping },
					strength: { type: "f", value: guiParams.strength },
					radius: { type: "f", value: guiParams.radius }
				};
				screenMat = new THREE.ShaderMaterial({
					uniforms: rtUniforms,
					vertexShader: document.getElementById( 'vs_rt' ).textContent,
					fragmentShader: document.getElementById( 'fs_rt' ).textContent
				});
				
				// main water material and mesh
				mainUniforms = {
					heightMap: { type: "t", value: rtTexture2 },
					scale: { type: "f", value: guiParams.scale },
					alpha: { type: "f", value: guiParams.alpha },
					colorMap: { type: "t", value: THREE.ImageUtils.loadTexture( '/static/img/py.jpg' ) },
					normalMap: { type: "t", value: normalMap },
					ambient: { type: "c", value: new THREE.Color(0xc5bbae) },
					diffuse: { type: "c", value: new THREE.Color(0xffffff) },
					specular: { type: "c", value: new THREE.Color(0xffffff) },
					invRadius: { type: "f", value: 0.0 },
					shininess: { type: "f", value: 50.0 },
					lightPos: { type: "v3", value: light.position }
				};				
				waterMat = new THREE.ShaderMaterial({
					uniforms: mainUniforms,
					vertexShader: document.getElementById( 'vs_setHeight' ).textContent,
					fragmentShader: document.getElementById( 'fs_setColor' ).textContent,
					transparent: true,
					side: THREE.DoubleSide
					//wireframe: true
				});
				
				// Setup normal material
				normalUniforms = {
					texture: { type: "t", value: rtTexture2 },
					delta: { type: "v2", value: new THREE.Vector2(delta, delta) },
					height: { type: "f", value: 0.05 }
				};
				normalMat = new THREE.ShaderMaterial({
					uniforms: normalUniforms,
					vertexShader: document.getElementById( 'vs_normal' ).textContent,
					fragmentShader: document.getElementById( 'fs_normal' ).textContent
				});
			}


			//------------------------------------------
			// Setup the render-to-texture scene
			//------------------------------------------
			function setupRTTScene(){
				cameraRTT = new THREE.OrthographicCamera( simRes / - 2, simRes / 2, simRes / 2, simRes / - 2, -10000, 10000 );
				
				var screenGeo = new THREE.PlaneBufferGeometry( simRes, simRes );
				screenQuad = new THREE.Mesh( screenGeo, screenMat );
        screenQuad.name = "screenQuad";
				screenQuad.position.z = -100;
				sceneRTT.add( screenQuad );
			}
			
			
			//------------------------------------------
			// Setup the main scene
			//------------------------------------------
			function setupMainScene(){

        //setup camera
        
        
        var viewAngle = 55.0;
        var near = 0.1;
        var canvasRatio = window.innerWidth / window.innerHeight;
        var far = 3000000;
        var camera = new THREE.PerspectiveCamera(viewAngle, canvasRatio, near, far);
        var rotateRadius = 300.0;
        camera.position.set(rotateRadius*Math.cos(Math.PI/4.0), 55, -rotateRadius*Math.sin(Math.PI/4.0));
        camera.lookAt(new THREE.Vector3(0, 0, 0));
    
        // CONTROLS
        cameraControls = new THREE.OrbitAndPanControls(camera, renderer.domElement);
        
        
				
				var waterGeo = new THREE.PlaneBufferGeometry( 2048, 2048, simRes-1, simRes-1 );				
				water = new THREE.Mesh( waterGeo , waterMat );
        water.name = "water";
				water.rotation.x = THREE.Math.degToRad(-90);
        water.rotation.z = THREE.Math.degToRad(-90);
				scene.add( water );
				

			}
			
		


			//------------------------------------------
			// Setup mouse event handlers
			//------------------------------------------
			function setupControls(){
				// Add mouse controls
				renderer.domElement.onmousedown = function (event) 
				{
					if (event.button === 0)
					{
            var intersects = getRayCastIntersects(event.clientX, event.clientY);
            var u = 0.0; 
            var v = 0.0;
            $.each(intersects, function(key, val){
              if(val.object.name == "water"){
                //console.log("find water");
                rtUniforms.mouseActive.value = 2;
                cameraControls.noRotate = true;
                mouseDown = true;
                
                //create ripple
                var face = val.face;
                u += val.object.geometry.attributes.uv.array[face.a*2];
                v += val.object.geometry.attributes.uv.array[face.a*2 + 1];
                u += val.object.geometry.attributes.uv.array[face.b*2];
                v += val.object.geometry.attributes.uv.array[face.b*2 + 1];
                u += val.object.geometry.attributes.uv.array[face.c*2];
                v += val.object.geometry.attributes.uv.array[face.c*2 + 1];

                u /= 3.0;
                v /= 3.0;
                rtUniforms.mousePoint.value.set(u, v);
                return false;
              }
            });
						

					}
				};
				
				renderer.domElement.onmouseup = function (event) 
				{

					mouseDown = false;
					rtUniforms.mouseActive.value = 0;
          cameraControls.noRotate = false;
          
				};
				
				renderer.domElement.onmouseout = function () 
				{
					rtUniforms.mouseActive.value = 0;
				};
				
				
				

				renderer.domElement.onmousemove = function (event) 
				{
          //rtUniforms.mouseActive.value = mouseDown ? 2 : 0;
          if(!mouseDown) return;
					var intersects = getRayCastIntersects(event.clientX, event.clientY);
          var u = 0.0; 
          var v = 0.0;
        
          $.each(intersects, function(key, val){
              if(val.object.name == "water"){
                var face = val.face;
                u += val.object.geometry.attributes.uv.array[face.a*2];
                v += val.object.geometry.attributes.uv.array[face.a*2 + 1];
                u += val.object.geometry.attributes.uv.array[face.b*2];
                v += val.object.geometry.attributes.uv.array[face.b*2 + 1];
                u += val.object.geometry.attributes.uv.array[face.c*2];
                v += val.object.geometry.attributes.uv.array[face.c*2 + 1];

                u /= 3.0;
                v /= 3.0;
                rtUniforms.mousePoint.value.set(u, v);
                //rtUniforms.mouseActive.value = mouseDown ? 2 : 0;
                return false;
              }
          });
				};
			}

      function getRayCastIntersects(x, y){
        var canvasWidth = window.innerWidth;
        var canvasHeight = window.innerHeight;
        var camera = cameraControls.object;
        var mouseVector = new THREE.Vector2( -1 + 2*(x / canvasWidth),
                                             1  - 2*(y / canvasHeight));
        var raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouseVector, camera);
        return raycaster.intersectObject(scene.getObjectByName( "water" ),false);
      }
			
			//------------------------------------------
			// Main loop
			//------------------------------------------
			function update() {
				requestAnimationFrame( update );

				if (animateLight)
				{
          console.log(clock.getElapsedTime());
          //clock.start();
					light.position.x = Math.sin(clock.getElapsedTime() + Math.PI/4) * 850.0;
					light.position.z = Math.cos(clock.getElapsedTime() + Math.PI/4) * 850.0;
					guiNeedsUpdate = true;
				}

				// Refresh GUI
				if (guiNeedsUpdate)
				{
					// Iterate over all controllers
					for (var i in gui.__controllers) 
					{
						gui.__controllers[i].updateDisplay();
					}
					for (var j in mainFolder.__controllers) 
					{
						mainFolder.__controllers[j].updateDisplay();
					}
					for (var k in lightFolder.__controllers) 
					{
						lightFolder.__controllers[k].updateDisplay();
					}
					for (var l in waterColorFolder.__controllers) 
					{
						waterColorFolder.__controllers[l].updateDisplay();
					}
					guiNeedsUpdate = false;
				}
				render();
        cameraControls.update();
			}

			
			//------------------------------------------
			// Main rendering
			//------------------------------------------
			function render() {
				renderer.clear();
				
				// Run heightMap simulation, updating both buffers
				stepSim();
				stepSim();
				
				// Generate normalMap from new heightMap
				updateNormals();
				
				// Final render pass
        renderer.render( scene, cameraControls.object );
			}
			
			
			//------------------------------------------
			// A single simulation step
			//------------------------------------------
			function stepSim(){
				// Run the ripple propagation in the sceneRTT fragment shader and
				// render it into rtTexture
				renderer.render( sceneRTT, cameraRTT, rtTexture, true );

				// Swap buffers
				swapBuffers();
			}
			
			
			//------------------------------------------
			// Generate normalMap
			//------------------------------------------
			function updateNormals(){
				// Switch to custom normalmap material
				screenQuad.material = normalMat;
				
				// Render the normals into the buffers. This mixes normal colors in.
				renderer.render( sceneRTT, cameraRTT, normalMap, true );
				
				// Switch back to simulation material
				screenQuad.material = screenMat;
			}
		
		
			//------------------------------------------
			// Swaps the rendering buffers
			//------------------------------------------
			function swapBuffers(){
				var a = rtTexture2;
				rtTexture2 = rtTexture;
				rtTexture = a;
				rtUniforms.texture.value = rtTexture2;
			}
		</script>
	</body>
</html>